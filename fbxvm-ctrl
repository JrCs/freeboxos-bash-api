#! /bin/bash
# NBA :   
# NBA :         Written by nbanba for managing Freebox Delta Virtual Machines 
# NBA :           Licence : GNU - use, modify, redistribute ... and Enjoy !                 
# NBA :   
# NBA : This software is not provide by Free (vendor of Freebox Delta) => use at your own risk !         
# NBA :             
##################################################################################################
# NBA : 20211114 
# NBA : Application to control VMs on Freebox Delta
# NBA : Using some functions from fbx-delta-nba_bash_api.sh 
# NBA : highly forked by NBA from https://github.com/JrCs/freeboxos-bash-api
# NBA : list, start, shutdown (acpi), stop (force), restart
# 
# NBA : 20220506 
# NBA : Adding support for accessing VM console from chassis using freebox delta websocket API
# NBA : + suppressing freebox hardcoded URL (for use with HTTPS and WebSocket)
# 
# NBA : 20220509 
# NBA : Calling 'check_tool' function to check for necessary external tools
#
# NBA : 20220511
# NBA : Adding support of detached and screen mode for console
# NBA : Updating 'usage'
#
# NBA : 20220512 - 20220517   ---> Big commit !
# NBA : Adding support of full VM management :   
# NBA : - add VM / add disk 
# NBA : - del VM / del disk
# NBA : - list VM / list VM disk
# NBA : - resize VM disk
# NBA : - print VM detail
# NBA : - modify VM parameters
# NBA : - keeping existing REST HTTP API functionnalities : start, stop, restart, shutdown 
# NBA : - keeping existing WEBSOCKET API functionnalities : console
#
##################################################################################################
#    
#


# Authentification

MY_APP_ID="app-vm"
MY_APP_TOKEN="app-vm_token"
API="vm"


# Common variables

red='\033[01;31m'
RED='\033[31m'
blue='\033[01;34m'
BLUE='\033[34m'
green='\033[01;32m'
GREEN='\033[32m'
purpl='\033[01;35m'
PURPL='\033[35m' 
WHITE='\033[37m' 
white='\033[01;37m' 
white='\033[01;37m' 
norm='\033[00m'

vmid="$1"
action="$2"
mode="$3"


# source fbx-delta-nba_bash_api.sh from the current directory 

source ${0/`basename $0`/}/fbx-delta-nba_bash_api.sh

# login

login_freebox "$MY_APP_ID" "$MY_APP_TOKEN"


# functions

print_vm_summary () {
	echo -e "\nVIRTUAL MACHINE ID, NAME, MAC AND STATUS : \n"	

	local i=0
	answer=$(call_freebox_api "/$API/")
	dump_json_keys_values "$answer" >/dev/null
	while [[ $(get_json_value_for_key "$answer" "result[$i].name") != "" ]] 
	do
		name=$(get_json_value_for_key "$answer" "result[$i].name")
		id=$(get_json_value_for_key "$answer" "result[$i].id")
		mac=$(get_json_value_for_key "$answer" "result[$i].mac")
		state=$(get_json_value_for_key "$answer" "result[$i].status")
		if [ ! -z "$name" ];
			then
			echo -e "VM-$i:\t${red}id: ${id}${norm} $([ "$state" == "running" ] && echo -e "\t status: ${green}${state}${norm}" || echo -e "\t status: ${purpl}${state}${norm}") \tname: $name \tmac_address: $mac" 
		fi
		((i++))
	done	
	echo
}


get_vm_object_var () {

local i=0
answer=$(call_freebox_api "/$API/")
dump_json_keys_values "$answer" >/dev/null

while [[ $(get_json_value_for_key "$answer" "result[$i].name") != "" ]] 
do
        mac[$i]=$(get_json_value_for_key "$answer" "result[$i].mac")
        userdata[$i]=$(get_json_value_for_key "$answer" "result[$i].cloudinit_userdata")
        cd_path[$i]=$(get_json_value_for_key "$answer" "result[$i].cd_path")
        id[$i]=$(get_json_value_for_key "$answer" "result[$i].id")
        os[$i]=$(get_json_value_for_key "$answer" "result[$i].os")
        cloudinit[$i]=$(get_json_value_for_key "$answer" "result[$i].enable_cloudinit")
        disk_path[$i]=$(get_json_value_for_key "$answer" "result[$i].disk_path")
        vcpus[$i]=$(get_json_value_for_key "$answer" "result[$i].vcpus")
        memory[$i]=$(get_json_value_for_key "$answer" "result[$i].memory")
	name[$i]=$(get_json_value_for_key "$answer" "result[$i].name")
	cloudinit_hostname[$i]=$(get_json_value_for_key "$answer" "result[$i].cloudinit_hostname")
        state[$i]=$(get_json_value_for_key "$answer" "result[$i].status")
        usb_0[$i]=$(get_json_value_for_key "$answer" "result[$i].bind_usb_ports[0]")
        usb_1[$i]=$(get_json_value_for_key "$answer" "result[$i].bind_usb_ports[1]")
        usb[$i]=$(echo "[\"${usb_0[$i]}\",\"${usb_1[$i]}\"]")
        enable_screen[$i]=$(get_json_value_for_key "$answer" "result[$i].enable_screen")
        disk_type[$i]=$(get_json_value_for_key "$answer" "result[$i].disk_type")

	vm_object_[$i]="{\"mac\":${mac[$i]},\"cloudinit_userdata\":${userdata[$i]},\"cd_path\":${cd_path[$i]},\"id\":${id[$i]},\"os\":${os[$i]},\"enable_cloudinit\":${cloudinit[$i]},\"disk_path\":${disk_path[$i]},\"vcpus\":${vcpus[$i]},\"memory\":${memory[$i]},\"name\":${name[$i]},\"cloudinit_hostname\":${cloudinit_hostname[$i]},\"status\":${state[$i]},\"bind_usb_ports\":${usb[$i]},\"enable_screen\":${enable_screen[$i]},\"disk_type\":${disk_type[$i]}}"

        ((i++))
done
}

print_vm_detail () {

	[ -z "$1" ] && echo "function print_vm_info take 'id' as argument" && exit 33
	local idvm="$1"
	get_vm_object_var

        if [ ! -z "$idvm" ];
        	then
        	echo -e "\nVM-$idvm : Full details properties :\n"
        	echo -e "\tname = ${GREEN}${name[$idvm]}${norm}" 
        	echo -e "\tid = ${RED}${id[$idvm]}${norm}" 
        	[ "${state[$idvm]}" == "running" ] \
                	&& echo -e "\tstatus = ${green}${state[$idvm]}${norm}" \
                	|| echo -e "\tstatus = ${purpl}${state[$idvm]}${norm}" 
        	echo -e "\tmemory = ${RED}${memory[$idvm]}${norm}" 
        	echo -e "\tvcpus = ${RED}${vcpus[$idvm]}${norm}" 
        	echo -e "\tdisk_type = ${GREEN}${disk_type[$idvm]}${norm}" 
		echo -e "\tdisk_path = ${RED}$(echo ${disk_path[$idvm]}|base64 -d)${norm}" 
		echo -e "\tcd_path = ${RED}$(echo ${cd_path[$idvm]}|base64 -d)${norm}" 
        	echo -e "\tmac_address = ${GREEN}${mac[$idvm]}${norm}" 
        	echo -e "\tos = ${GREEN}${os[$idvm]}${norm}" 
        	echo -e "\tenable_screen = ${RED}${enable_screen[$idvm]}${norm}" 
        	echo -e "\tbind_usb_ports = ${RED}${usb[$idvm]}${norm}" 
        	echo -e "\tenable_cloudinit = ${GREEN}${cloudinit[$idvm]}${norm}" 
        	echo -e "\tcloudinit_hostname = ${GREEN}${cloudinit_hostname[$idvm]}${norm}" 
        	echo -e "\tcloudinit_userdata = ${GREEN}${userdata[$idvm]}${norm}" 
		echo -e "\tjson_vm_object = ${BLUE}${vm_object_[$idvm]}${norm}\n"
	fi

}

feed_vm_variables () {
[ -z "$1" ] && echo "function feed_vm_variables take at least 'id' and 'param' argument" && exit 34


	local idvm="$1"
	local param=("${@:2}")
	local idparam=0
	local nameparam=("")
	local valueparam=("")
	vm_object_modif=("")
	bind_usb=0
	ci_userdata=0

	get_vm_object_var

	
	while [[ "${param[$idparam]}" != "" ]] 
	do
		nameparam=$(echo "${param[$idparam]}"|cut -d= -f1)
		valueparam=$(echo "${param[$idparam]}"|cut -d= -f2-)
		[[ "${nameparam}" == "name" ]] && name[$idvm]=${valueparam}
		[[ "${nameparam}" == "vcpus" ]] && vcpus[$idvm]=${valueparam}
		[[ "${nameparam}" == "memory" ]] && memory[$idvm]=${valueparam}
		[[ "${nameparam}" == "disk_type" ]] && disk_type[$idvm]=${valueparam}
		[[ "${nameparam}" == "disk_path" ]] && disk_path[$idvm]=$(echo ${valueparam}|base64)
		[[ "${nameparam}" == "cd_path" ]] && cd_path[$idvm]=$(echo ${valueparam}|base64)
		[[ "${nameparam}" == "enable_screen" ]] && enable_screen[$idvm]=${valueparam}
		[[ "${nameparam}" == "bind_usb_ports" ]] && bind_usb=1 && usb[$idvm]=${valueparam}
		[[ "${nameparam}" == "os" ]] && os[$idvm]=${valueparam}
		[[ "${nameparam}" == "enable_cloudinit" ]] && cloudinit[$idvm]=${valueparam}
		[[ "${nameparam}" == "cloudinit_hostname" ]] && cloudinit_hostname[$idvm]=${valueparam}
		[[ "${nameparam}" == "cloudinit_userdata" ]] &&  ci_userdata=1 \
		&& local ud=$(sed -e ':a' -e 'N' -e '$!ba' -e 's/\n/\\n/g' ${valueparam}) \
		&& userdata[$idvm]=$(echo ${ud})   # converting yaml file to one-line yaml

	        ((idparam++))

	done


	# Convert text to boolean
[[ "${cloudinit[$idvm]}" == "true" ]] && cloudinit[$idvm]="1" || cloudinit[$idvm]="0"
[[ "${enable_screen[$idvm]}" == "true" ]] && enable_screen[$idvm]="1" || enable_screen[$idvm]="0"

	# Update 'bind_usb_ports' and 'cloudinit_userdata' only if it had been specify on cmdline
if [[ "${bind_usb}" -eq "1" ]] 

			#(usb+userdata) and (usb+no-userdata)
	then	[[ "${ci_userdata}" -eq "1" ]] \
		&& vm_object_modif[$idvm]="{\"mac\":\"${mac[$idvm]}\",\"cloudinit_userdata\":\"${userdata[$idvm]}\",\"cd_path\":\"${cd_path[$idvm]}\",\"id\":\"${id[$idvm]}\",\"os\":\"${os[$idvm]}\",\"enable_cloudinit\":\"${cloudinit[$idvm]}\",\"disk_path\":\"${disk_path[$idvm]}\",\"vcpus\":\"${vcpus[$idvm]}\",\"memory\":\"${memory[$idvm]}\",\"name\":\"${name[$idvm]}\",\"cloudinit_hostname\":\"${cloudinit_hostname[$idvm]}\",\"status\":\"${state[$idvm]}\",\"bind_usb_ports\":[${usb[$idvm]}],\"enable_screen\":\"${enable_screen[$idvm]}\",\"disk_type\":\"${disk_type[$idvm]}\"}" \
        	|| vm_object_modif[$idvm]="{\"mac\":\"${mac[$idvm]}\",\"cd_path\":\"${cd_path[$idvm]}\",\"id\":\"${id[$idvm]}\",\"os\":\"${os[$idvm]}\",\"enable_cloudinit\":\"${cloudinit[$idvm]}\",\"disk_path\":\"${disk_path[$idvm]}\",\"vcpus\":\"${vcpus[$idvm]}\",\"memory\":\"${memory[$idvm]}\",\"name\":\"${name[$idvm]}\",\"cloudinit_hostname\":\"${cloudinit_hostname[$idvm]}\",\"status\":\"${state[$idvm]}\",\"bind_usb_ports\":[${usb[$idvm]}],\"enable_screen\":\"${enable_screen[$idvm]}\",\"disk_type\":\"${disk_type[$idvm]}\"}"
	
			#(no-usb+userdata) and  (no-usb+no-userdata)
	else [[ "${ci_userdata}" -eq "1" ]] \
		&& vm_object_modif[$idvm]="{\"mac\":\"${mac[$idvm]}\",\"cloudinit_userdata\":\"${userdata[$idvm]}\",\"cd_path\":\"${cd_path[$idvm]}\",\"id\":\"${id[$idvm]}\",\"os\":\"${os[$idvm]}\",\"enable_cloudinit\":\"${cloudinit[$idvm]}\",\"disk_path\":\"${disk_path[$idvm]}\",\"vcpus\":\"${vcpus[$idvm]}\",\"memory\":\"${memory[$idvm]}\",\"name\":\"${name[$idvm]}\",\"cloudinit_hostname\":\"${cloudinit_hostname[$idvm]}\",\"status\":\"${state[$idvm]}\",\"enable_screen\":\"${enable_screen[$idvm]}\",\"disk_type\":\"${disk_type[$idvm]}\"}" \
        	|| vm_object_modif[$idvm]="{\"mac\":\"${mac[$idvm]}\",\"cd_path\":\"${cd_path[$idvm]}\",\"id\":\"${id[$idvm]}\",\"os\":\"${os[$idvm]}\",\"enable_cloudinit\":\"${cloudinit[$idvm]}\",\"disk_path\":\"${disk_path[$idvm]}\",\"vcpus\":\"${vcpus[$idvm]}\",\"memory\":\"${memory[$idvm]}\",\"name\":\"${name[$idvm]}\",\"cloudinit_hostname\":\"${cloudinit_hostname[$idvm]}\",\"status\":\"${state[$idvm]}\",\"enable_screen\":\"${enable_screen[$idvm]}\",\"disk_type\":\"${disk_type[$idvm]}\"}"  
fi

}	


create_vm_variables () {
[ -z "$1" ] && echo "function feed_vm_variables take at least 'id' and 'param' argument" && exit 34

        local param=("${@}")
        local idparam=0
        local nameparam=("")
        local valueparam=("")
        vm_object_create=("")

        while [[ "${param[$idparam]}" != "" ]] 
        do
                nameparam=$(echo "${param[$idparam]}"|cut -d= -f1)
                valueparam=$(echo "${param[$idparam]}"|cut -d= -f2-)
                [[ "${nameparam}" == "name" ]] && local name=${valueparam}
                [[ "${nameparam}" == "vcpus" ]] && local vcpus=${valueparam}
                [[ "${nameparam}" == "memory" ]] && local memory=${valueparam}
                [[ "${nameparam}" == "disk_type" ]] && local disk_type=${valueparam}
                [[ "${nameparam}" == "disk_path" ]] && local disk_path=$(echo ${valueparam}|base64)
                [[ "${nameparam}" == "cd_path" ]] && local cd_path=$(echo ${valueparam}|base64)
                [[ "${nameparam}" == "enable_screen" ]] && local enable_screen=${valueparam}
                [[ "${nameparam}" == "bind_usb_ports" ]] && local usb=${valueparam}
                [[ "${nameparam}" == "os" ]] && local os=${valueparam}
                [[ "${nameparam}" == "enable_cloudinit" ]] && local cloudinit=${valueparam}
                [[ "${nameparam}" == "cloudinit_hostname" ]] && local cloudinit_hostname=${valueparam}
                [[ "${nameparam}" == "cloudinit_userdata" ]] \
                && local ud=$(sed -e ':a' -e 'N' -e '$!ba' -e 's/\n/\\n/g' ${valueparam}) \
                && local userdata=$(echo ${ud})   # converting yaml file to one-line yaml

                #echo "idparam $idparam : param[$idparam] : ${param[$idparam]}"  #debug 
                ((idparam++))
        done


        # Convert text to boolean
[[ "${cloudinit}" == "true" ]] && cloudinit="1" || cloudinit="0"
[[ "${enable_screen}" == "true" ]] && enable_screen="1" || enable_screen="0"

vm_object_create="{\"cloudinit_userdata\":\"${userdata}\",\"cd_path\":\"${cd_path}\",\"os\":\"${os}\",\"enable_cloudinit\":\"${cloudinit}\",\"disk_path\":\"${disk_path}\",\"vcpus\":\"${vcpus}\",\"memory\":\"${memory}\",\"name\":\"${name}\",\"cloudinit_hostname\":\"${cloudinit_hostname}\",\"bind_usb_ports\":[${usb}],\"enable_screen\":\"${enable_screen}\",\"disk_type\":\"${disk_type}\"}"

}

feeds_vmdisk_variables () {
[ -z "$1" ] && echo "function feed_vmdisk_variables need '<param>' argument" && exit 34

        local param=("${@}")
        local idparam=0
        local nameparam=("")
        local valueparam=("")
        vmdisk_object_create=("")
        vmdisk_object_resize=("")

        while [[ "${param[$idparam]}" != "" ]] 
        do
                nameparam=$(echo "${param[$idparam]}"|cut -d= -f1)
                valueparam=$(echo "${param[$idparam]}"|cut -d= -f2-)
                [[ "${nameparam}" == "disk_type" ]] && disk_type=${valueparam}
                [[ "${nameparam}" == "disk_path" ]] && disk_path=$(echo -n "${valueparam}"|base64)
                [[ "${nameparam}" == "size" ]] && size=${valueparam}
                [[ "${nameparam}" == "disk_shrink" ]] &&  shrink_allow=${valueparam}

                ((idparam++))
        done

        # Convert text to boolean
[[ "${shrink_allow}" == "true" ]] && shrink_allow="1" || shrink_allow="0"

vmdisk_object_create="{\"disk_path\":\"${disk_path}\",\"size\":\"${size}\",\"disk_type\":\"${disk_type}\"}"
vmdisk_object_resize="{\"disk_path\":\"${disk_path}\",\"size\":\"${size}\",\"shrink_allow\":\"${shrink_allow}\"}"

#echo -e "\nvmdisk_object_create :\n${vmdisk_object_create}"  # debug vmdisk_object_create
#echo -e "\nvmdisk_object_resize :\n${vmdisk_object_resize}"  # debug vmdisk_object_resize
}



add () {
# call 'add_vm' or 'add_disk' function depending on cmdline 2nd param
	[[ "$1" == "vm" ]] && add_vm ${@}
	[[ "$1" == "disk" ]] && add_disk ${@}
}	

del () {
# call 'del_vm' or 'del_disk' function depending on cmdline 2nd param
	[[ "$1" == "vm" ]] && del_vm ${@:2}
	[[ "$1" == "disk" ]] && del_disk ${@}
}	

del_disk () {
        feeds_vmdisk_variables ${@:2}

        local result=$(add_freebox_api "/fs/rm" "{\"files\":[\"${disk_path}\"]}" 2>&1)
	local task_id=$(get_json_value_for_key "${result}" result.id)

	[ -z "${task_id}" ] \
        && echo -e "\nERROR: ${RED}${result}${norm}" \
        && echo -e "${WHITE}delete task had not been created${norm}\n" \
        && exit 305 \
        || echo -e "\n${WHITE}task ${norm}${PURPL}#${task_id}${norm} ${WHITE}had been sucessfully created. Waiting for ${norm}${PURPL}task #${task_id}${norm}${WHITE} to complete...${norm}"
        local task_status=
        local task_result=
	while [[ ${task_result} != "done" && ${task_result} != "failed" ]]; do sleep 1;
                task_status=$(call_freebox_api "/fs/tasks/${task_id}") ;
                task_result=$(get_json_value_for_key "${task_status}" result.state)
		[[ "${task_result}" != "failed" ]] \
                && echo -e "${WHITE}task_status: ${norm}${GREEN}${task_status}${norm}" \
                || echo -e "${WHITE}task_status: ${norm}${RED}${task_status}${norm}"
        done \
                && local resdel=$(del_freebox_api  "/fs/tasks/$task_id") \
                && echo ${resdel} |grep -q '{"success":true' >/dev/null \
                && echo -e "${WHITE}operation completed, deleting finished ${norm}${PURPL}task #${task_id}${norm}${WHITE}: ${GREEN}${resdel}${norm}" \
                || echo -e "${WHITE}operation completed, deleting finished ${norm}${PURPL}task #${task_id}${norm}${WHITE}: ${RED}${resdel}${norm} \n"
}

list_vm_disk () {
        echo -e "\n${WHITE}VIRTUAL MACHINE DISK LIST : ${norm}\n"       
	local vm_disk_path=$(echo -n "$1"|base64)
	local answer=$(call_freebox_api "/fs/ls/${vm_disk_path}" 2>&1)
	local i=0
	while [[ $(get_json_value_for_key "$answer" "result[$i].name") != "" ]] 
		do
        		local type=$(get_json_value_for_key "$answer" "result[$i].type")
      		  	local index=$(get_json_value_for_key "$answer" "result[$i].index")
        		local link=$(get_json_value_for_key "$answer" "result[$i].link")
       		 	local modification=$(get_json_value_for_key "$answer" "result[$i].modification")
        		local hidden=$(get_json_value_for_key "$answer" "result[$i].hidden")
        		local mimetype=$(get_json_value_for_key "$answer" "result[$i].mimetype")
        		local name=$(get_json_value_for_key "$answer" "result[$i].name")
        		local path=$(get_json_value_for_key "$answer" "result[$i].path")
        		local size=$(get_json_value_for_key "$answer" "result[$i].size")
				if [[ "$mimetype" == "application/x-qemu-disk" ]]
					then
       					echo -e "DISK-$i:  \t${RED}index: ${index}${norm}\tname: ${GREEN}${name}${norm}\tsize: ${PURPL}${size} bytes${norm}" 
				fi
		((i++))
		done
echo
}

add_disk () {
        feeds_vmdisk_variables ${@:2}

	#test param for 'add disk'
	[[ -z "${disk_path}" && -z "${disk_type}" && -z "${size}" ]] \
		&& echo -e "\nERROR: ${RED}<param> for 'add disk' must be :${norm}\n${BLUE}disk_type=|disk_path=|size=${norm}\n" |tr "|" "\n" \
		&& echo -e "EXAMPLE:\n${BLUE}fbxvm-ctrl add disk disk_type=\"qcow2\" disk_path=\"/freeboxdisk/vmdiskpath/myvmdisk.qcow2\" size=\"10737418240\"     ${norm}"\
        	&& echo -e "\nPlease run ${0/.\//} with no parameters to get usage\n" \
	        && exit 263

	local result=$(add_freebox_api "/$API/disk/create" "${vmdisk_object_create}" 2>&1)
	create_vmdisk_task_id=$(get_json_value_for_key "${result}" result.id)
        [ -z "${create_vmdisk_task_id}" ] \
        && echo -e "\nERROR: ${RED}${result}${norm}" \
        && echo -e "${WHITE}create task had not been created${norm}\n" \
        && exit 305 \
        || echo -e "\n${WHITE}task ${norm}${PURPL}#${create_vmdisk_task_id}${norm} ${WHITE}had been sucessfully created. Waiting for ${norm}${PURPL}task #${create_vmdisk_task_id}${norm}${WHITE} to complete...${norm}"
        local task_result=
        local task_status=
	while [[ ${task_result} != "true" ]]; do sleep 1; 
		task_status=$(call_freebox_api "/$API/disk/task/$create_vmdisk_task_id") ;
		task_result=$(get_json_value_for_key "${task_status}" result.done)
                echo ${task_status} |grep -q '{"success":true,' >/dev/null \
                && echo -e "${WHITE}task_status: ${norm}${GREEN}${task_status}${norm}" \
                || echo -e "${WHITE}task_status: ${norm}${RED}${task_status}${norm}"
                done \
		&& local resdel=$(del_freebox_api  "/$API/disk/task/$create_vmdisk_task_id") \
                && echo ${resdel} |grep -q '{"success":true}' >/dev/null \
                && echo -e "${WHITE}operation completed, deleting finished ${norm}${PURPL}task #${create_vmdisk_task_id}${norm}${WHITE}: ${GREEN}${resdel}${norm}" \
                || echo -e "${WHITE}operation completed, deleting finished ${norm}${PURPL}task #${create_vmdisk_task_id}${norm}${WHITE}: ${RED}${resdel}${norm} \n"
#wrprogress "Waiting task ${create_vmdisk_task_id}" 1
}

resize_disk () {
        feeds_vmdisk_variables ${@}
	
	#test param for 'resize disk'
	[[ -z "${disk_path}" && -z "${disk_shrink}" && -z "${size}" ]] \
		&& echo -e "\nERROR: ${RED}<param> for 'resize disk' must be :${norm}\n${BLUE}disk_shrink=|disk_path=|size=${norm}\n" |tr "|" "\n" \
		&& echo -e "EXAMPLE:\n${BLUE}fbxvm-ctrl resize disk disk_shrink=\"0\" disk_path=\"/freeboxdisk/vmdiskpath/myvmdisk.qcow2\" size=\"10737418240\"     ${norm}"\
        	&& echo -e "\nPlease run ${0/.\//} with no parameters to get usage\n" \
	        && exit 304

	local result=$(add_freebox_api "/$API/disk/resize" "${vmdisk_object_resize}" 2>&1 )
	resize_vmdisk_task_id=$(get_json_value_for_key "${result}" result.id 2>/dev/null)

	[ -z "${resize_vmdisk_task_id}" ] \
	&& echo -e "\nERROR: ${RED}${result}${norm}" \
	&& echo -e "${WHITE}resize task had not been created${norm}\n" \
	&& exit 305 \
	|| echo -e "\n${WHITE}task ${norm}${PURPL}#${resize_vmdisk_task_id}${norm} ${WHITE}had been sucessfully created. Waiting for ${norm}${PURPL}task #${resize_vmdisk_task_id}${norm}${WHITE} to complete...${norm}"
	local task_status=
	local task_result=
        while [[ ${task_result} != "true" ]]; do sleep 1;
                task_status=$(call_freebox_api "/$API/disk/task/$resize_vmdisk_task_id") ;
                task_result=$(get_json_value_for_key "${task_status}" result.done)
		echo ${task_status} |grep -q '{"success":true,' >/dev/null \
                && echo -e "${WHITE}task_status: ${norm}${GREEN}${task_status}${norm}" \
                || echo -e "${WHITE}task_status: ${norm}${RED}${task_status}${norm}"
                done \
		&& local resdel=$(del_freebox_api  "/$API/disk/task/$resize_vmdisk_task_id") \
		&& echo ${resdel} |grep -q '{"success":true}' >/dev/null \
		&& echo -e "${WHITE}operation completed, deleting finished ${norm}${PURPL}task #${resize_vmdisk_task_id}${norm}${WHITE}: ${GREEN}${resdel}${norm}" \
		|| echo -e "${WHITE}operation completed, deleting finished ${norm}${PURPL}task #${resize_vmdisk_task_id}${norm}${WHITE}: ${RED}${resdel}${norm} \n"
}


add_vm () {
        local idvm="$1"
        create_vm_variables ${vmid} ${@:3}

	#echo -e "\ncall_freebox_api \"/$API\"  \"${vm_object_create}\""   # debug call_freebox_api 
		
	local result=$(add_freebox_api "/$API/" "${vm_object_create}" 2>&1)
	local result_one_line=$(echo  "${result}"|sed -e ':a' -e 'N' -e '$!ba' -e 's/\n/\\n/g')
    	local new_vm_id=$(get_json_value_for_key "${result_one_line}" result.id)
        [[ "${result}" =~ ^"{\"success\":true" ]] \
        && echo -e "
${WHITE}$(print_vm_detail ${new_vm_id}|sed -e ':a' -e 'N' -e '$!ba' -e 's/\n/\\n/g')${norm}
${WHITE}VM creation status:${norm} ${GREEN} $(echo -e  "${result}" |grep success |cut -d',' -f-1 |sed 's/true/true\}/')${norm}
${norm}" \
        || echo -e "
${WHITE}VM creation status:${norm} ${RED} ${result}
"
}


del_vm () {
        local idvm="$1"
	local result=$(del_freebox_api "/$API/$idvm" {}  2>&1;)
        [[ "${result}" =~ ^"{\"success\":true" ]] \
	&& echo -e "
${WHITE}VM delete status:${norm} ${GREEN} ${result}
${norm}" \
	|| echo -e "
${WHITE}VM delete status:${norm} ${RED} ${result}
${norm}"

}


modify_vm () {
	local idvm="$1"
	feed_vm_variables ${vmid} ${@:3}

		echo -e "\n${WHITE}New values for vm ID $idvm :${norm}\n"
                echo -e "\tname = ${GREEN}${name[$idvm]}${norm}" 
                echo -e "\tid = ${PURPL}${id[$idvm]}${norm}" 
                echo -e "\tstatus = ${PURPL}${state[$idvm]}${norm}" 
                echo -e "\tmemory = ${GREEN}${memory[$idvm]}${norm}" 
                echo -e "\tvcpus = ${GREEN}${vcpus[$idvm]}${norm}" 
                echo -e "\tdisk_type = ${GREEN}${disk_type[$idvm]}${norm}" 
                echo -e "\tdisk_path = ${GREEN}$(echo ${disk_path[$idvm]}|base64 -d)${norm}" 
                echo -e "\tcd_path = ${GREEN}$(echo ${cd_path[$idvm]}|base64 -d)${norm}" 
                echo -e "\tmac_address = ${PURPL}${mac[$idvm]}${norm}" 
                echo -e "\tos = ${GREEN}${os[$idvm]}${norm}" 
                echo -e "\tenable_screen = ${GREEN}${enable_screen[$idvm]}${norm}"
                echo -e "\tbind_usb_ports = ${GREEN}${usb[$idvm]}${norm}" 
                echo -e "\tenable_cloudinit = ${GREEN}${cloudinit[$idvm]}${norm}" 
                echo -e "\tcloudinit_hostname = ${GREEN}${cloudinit_hostname[$idvm]}${norm}" 
                [[ "${ci_userdata}" -eq "1" ]] \
             && echo -e "\tcloudinit_userdata = ${GREEN}${userdata[$idvm]}${norm}" \
             || echo -e "\tcloudinit_userdata = ${RED}<reset to null>${norm}" 
                #echo -e "\tjson_vm_object_modif = ${BLUE}${vm_object_modif[$idvm]}${norm}\n"    # debug
		#echo -e "\tjson_vm_object = ${BLUE}${vm_object_[$idvm]}${norm}\n"    # debug

	echo -e "

${WHITE}VM-${vmid} modification status:${norm} $(
update_freebox_api "/$API/$vmid"  "${vm_object_modif[$idvm]}" \
	|cut -d'"' -f-3 \
	|sed 's/,/}/g' \
	|xargs -I "{}" echo -e "$RED {} ${norm}";
	)"
}


# usage

usage () {
if [[ -z "$1" ]]; 
	then 
	echo -e "\n${WHITE}${0/.\//} USE FREEBOX REST API TO MANAGE FREEBOX-DELTA VIRTUAL MACHINES${norm}\n" 
	echo -e "usage: $0 ${red}list${norm}" 
	echo -e "usage: $0 ${red}listdisk${norm}" "/path/to/freebox_VM/folder"
	echo -e "usage: $0 ${red}<verb>${norm} <object> <param>"
	echo -e "usage: $0 ${red}vmid${norm} <action> <param|mode(optionnal)>" 
	echo -e "\n- action = <start|shutdown(acpi)|stop(force)|restart|detail|modify|console>" 
	echo -e "- param  = <name=|vcpu=|memory=|disk_type=|disk_path=|...>"
	echo -e "- mode   = ('console' only & optionnal) = <\"\"|detached|screen>\n"
	echo -e "VERB :   - add        : create virtual machine or create virtual machine disk 
         - del        : delete virtual machine or delete virtual machine disk 
         - resize     : resize virtual machine disk - disk-only 
"
  	echo -e "ACTION : - start     : simply start VM
   	 - shutdown  : (acpi) send an ACPI shutdown command to VM
   	 - stop      : (force) set a PSU restart command to VM = electrical stop
   	 - restart   : simply restart VM 
   	 - detail    : print VM configuration detail (all parameters of Freebox API VM object)
   	 - modify    : modify VM parameter
   	 - console   : connect VM console
"	
	echo -e "OBJECT : - vm        : freebox delta virtual machine 
         - disk      : freebox delta virtual machine
"
  	echo -e "PARAM :  - name=                : name of this VM - VM-only (string, max 31 characters) 
         - vcpu=                : number of virtual CPUs to allocate to this VM - VM-only (integer)
  	 - memory=              : memory allocated to this VM in megabytes - VM-only (integer)
	 - disk_type=           : type of disk image, values : qcow2|raw - VM+disk (string)
  	 - disk_path=           : path to the hard disk image of this VM - VM+disk (string)
  	 - disk_size=           : hard disk final size in bytes (integer) - disk-only
  	 - disk_shrink=         : allow or not the disk to be shrink - disk-only (bool) DANGEROUS
  	 - cd_path=             : path to CDROM device ISO image - optional - VM-only (string) 
  	 - os=                  : VM OS: unknown|fedora|debian|ubuntu|freebsd|centos|jeedom|homebridge 
  	 - enable_screen=       : virtual screen using VNC websocket protocol - VM-only (bool) 
  	 - bind_usb_ports=      : syntax : bind_usb_ports='\"usb-external-type-c\",\"usb-external-type-a\"' 
	 - enable_cloudinit=    : enable or not  passing data through cloudinit - VM-only (bool) 
  	 - cloudinit_hostname=  : when cloudinit is enabled: hostname (string, max 59 characters)
  	 - cloudinit_userdata=  : path to file containing user-data raw yaml (file max 32767 characters)

WARNING : when modifying VM, if you do not explicitly specify on the cmdline ${PURPL}'cloudinit_userdata=\$val'${norm},
	  previous values for ${PURPL}'cloudinit_userdata'${norm} parameter ${RED}will be reset to null ('')${norm} 
"	
	echo -e "MODE ('console' only options) :
 	 - if <mode> is ommited, console is launched directly from terminal (basic mode)	
	${GREEN} - if <mode> is \"detached\" console is launched detached from terminal (best mode)${norm}	
	 - if <mode> is \"screen\" console is launched in a screen (alternative mode)	

---> ${RED}\"detached\"${norm} and ${RED}\"screen\"${norm} mode require you install ${RED}\"GNU dtach\"${norm} or ${RED}\"GNU screen\"${norm} programm${norm}\n"	

#	print_vm_summary
	exit 25
fi
}


# test param 

testparam () {

# $1 must be 'list' or 'listdisk' or 'add' or 'del' OR 'vmid' (vmid is a number !) :
[ -n "$1" ] && [ "$1" -eq "$1" ] 2>/dev/null
[ $? -ne 0 ] \
	&& [[ "$1" != "list" ]] && [[ "$1" != "listdisk" ]] \
	&& [[ "$1" != "add" ]] && [[ "$1" != "del" ]]  && [[ "$1" != "resize" ]] \
	&& echo -e "\nERROR: ${RED}Enter 'list' 'listdisk' 'add' 'del' 'resize' or 'id' ('id' must be a number)${norm}" \
	&& echo -e "Please run ${0/.\//} with no parameters to get usage\n" \
	&& exit 261

[[ "$1" == "listdisk" ]] && [[ -z  "$2" ]] \
	&& echo -e "\nERROR: ${RED}listdisk need '/path/to/freebox_VM/folder' argument\n${norm}" \
        && echo -e "Please run ${0/.\//} with no parameters to get usage\n" \
        && exit 311

[[ "$1" == "add" ]] && [[ "$2" != "vm" && "$2" != "disk" ]] \
	&& echo -e "\nERROR: ${RED}add need either \"vm\" or \"disk\" parameter \n${norm}" \
	&& echo -e "Please run ${0/.\//} with no parameters to get usage\n" \
	&& exit 265


#if $1 = add and $2 = vm $3 must match ^(name|vcpu|memory|disk_type|disk_path|cd_path|os|enable_screen|bind_usb_ports|enable_cloudinit|cloudinit_hostname|cloudinit_userdata)

[[ "$1" == "add" ]] && [[ "$2" == "vm" ]] \
        && [[ "$(echo $3|cut -d= -f1)" != "name" \
        && "$(echo $3|cut -d= -f1)" != "memory" \
        && "$(echo $3|cut -d= -f1)" != "vcpus" \
        && "$(echo $3|cut -d= -f1)" != "disk_type" \
        && "$(echo $3|cut -d= -f1)" != "disk_path" \
        && "$(echo $3|cut -d= -f1)" != "cd_path" \
        && "$(echo $3|cut -d= -f1)" != "os" \
        && "$(echo $3|cut -d= -f1)" != "enable_screen" \
        && "$(echo $3|cut -d= -f1)" != "bind_usb_ports" \
        && "$(echo $3|cut -d= -f1)" != "enable_cloudinit" \
        && "$(echo $3|cut -d= -f1)" != "cloudinit_hostname" \
        && "$(echo $3|cut -d= -f1)" != "cloudinit_userdata" ]] \
        && echo -e "\nERROR: ${RED}<param> must be some of:${norm}${BLUE}
name=|vcpu=|memory=|disk_type=|disk_path=|cd_path=|os=|enable_screen=|bind_usb_ports=|enable_cloudinit=|cloudinit_hostname=|cloudinit_userdata=${norm}\n" |tr "|" "\n"\
	&& echo -e "NOTE: ${RED}minimum parameters to specify on cmdline to create a VM: ${norm}\n${BLUE}disk_type= \ndisk_path= \nvcpus= \nmemory= \nname= ${norm}\n" \
	&& echo -e "EXAMPLE:\n${BLUE}fbxvm-ctrl add vm disk_type=\"qcow2\" disk_path=\"/freeboxdisk/vmdiskpath/myvmdisk.qcow2\" vcpus=\"1\" memory=\"2048\" cd_path=\"/freeboxdisk/vmisopath/debian-11.0.0-arm64-netinst.iso\" os=\"debian\" enable_screen=\"true\" cloudinit_hostname=\"14RV-FSRV-49\" cloudinit_userdata=\"cloudinit-userdata.yml\" bind_usb_ports='\"usb-external-type-c\",\"usb-external-type-a\"' name=\"14RV-FSRV-49.dmz.lan\"${norm}\n" \
        && echo -e "Please run ${0/.\//} with no parameters to get usage\n" \
	&& exit 262

# [[ "$2" == "disk" ]]  --> detailed <param> check in add and resize functions 
[[ "$1" == "add" ]] && [[ "$2" == "disk" ]] \
	&& [[ -z "$3" ]] \
	&& echo -e "\nERROR: ${RED}<param> for 'add disk' must be:${norm}\n${BLUE}disk_type=|disk_path=|size=${norm}\n" |tr "|" "\n" \
	&& echo -e "EXAMPLE:\n${BLUE}fbxvm-ctrl add disk disk_type=\"qcow2\" disk_path=\"/freeboxdisk/vmdiskpath/myvmdisk.qcow2\" size=\"10737418240\"     ${norm}"\
	&& echo -e "\nPlease run ${0/.\//} with no parameters to get usage\n" \
	&& exit 263



[[ "$1" == "del" ]] && [[ "$2" != "vm" && "$2" != "disk" ]] \
	&& echo -e "\nERROR: ${RED}del need either \"vm\" or \"disk\" parameter \n${norm}" \
	&& echo -e "Please run ${0/.\//} with no parameters to get usage\n" \
	&& exit 295

[[ "$1" == "del" ]] && [[ "$2" == "vm" ]] \
	&& [[ -z "$3" ]] \
	&& echo -e "\nERROR: ${RED}you must specify a VM id${norm}\n\nEXAMPLE:\n${BLUE}fbxvm-ctrl del vm 31 ${norm}\n" \
	&& exit 292

[[ "$1" == "del" ]] && [[ "$2" == "vm" ]] \
        && [ -n "$3" ] && [ "$3" -eq "$3" ] 2>/dev/null \
        [ $? -ne 0 ] \
        && echo -e "\nERROR: ${RED}id must be a number!\n${norm}" \
        && exit 293

[[ "$1" == "del" ]] && [[ "$2" == "disk" ]] \
        && [[ "$(echo $3|cut -d= -f1)" != "disk_path" ]] && echo -e "\nERROR: ${RED}you must specify the option \"disk_path=\"${norm}\n\nEXAMPLE:\n${BLUE}fbxvm-ctrl del disk disk_path=\"/FBX-2000G/box-vm/14RV-FSRV-49.qcow2\" ${norm}\n" \
        && exit 294

[[ "$1" == "del" ]] && [[ "$2" == "disk" ]] \
        && [ -n "$3" ] && [ "$3" -eq "$3" ] 2>/dev/null \
        && [ $? -ne 0 ] \
        && echo -e "\nERROR: ${RED}id must be a number!\n${norm}" \
        && exit 291

[[ "$1" == "resize" ]] && [[ "$2" != "disk" ]] \
	&& echo -e "\nERROR: ${RED}resize need \"disk\" parameter \n${norm}" \
        && echo -e "Please run ${0/.\//} with no parameters to get usage\n" \
        && exit 300

# [[ "$2" == "disk" ]]  --> detailed <param> check in add and resize functions 
[[ "$1" == "resize" ]] && [[ "$2" == "disk" ]] \
        && [[ -z "$3" ]] \
	&& echo -e "\nERROR: ${RED}<param> for 'resize disk' must be :${norm}\n${BLUE}disk_shrink=|disk_path=|size=${norm}\n" |tr "|" "\n" \
        && echo -e "EXAMPLE:\n${BLUE}fbxvm-ctrl resize disk disk_shrink=\"0\" disk_path=\"/freeboxdisk/vmdiskpath/myvmdisk.qcow2\" size=\"10737418240\"     ${norm}"\
        && echo -e "\nPlease run ${0/.\//} with no parameters to get usage\n" \
        && exit 301

# <action> $2 must be one of start|shutdown|stop|restart|detail|console
# test $2 only if $1 != list or add or del
	[[ "$1" != "list" && "$1" != "listdisk" && "$1" != "add" && "$1" != "del" && "$1" != "resize" ]] \
	&& [[ "$2" != "start" \
	&& "$2" != "stop" \
	&& "$2" != "restart" \
	&& "$2" != "shutdown" \
	&& "$2" != "detail" \
	&& "$2" != "modify" \
	&& "$2" != "console" ]] \
	&& echo -e "\nERROR: ${RED}<action> must be one of \"start\" \"shutdown\" \"stop\" \"restart\" \"detail\" \"modify\"  \"console\"${norm}" \
	&& echo -e "Please run ${0/.\//} with no parameters to get usage\n" \
	&& exit 27

# if $2 = console $3 must be one of ''|detached|screen 
	[[ "$2" == "console" ]] \
	&& [[ "$3" != "" \
	&& "$3" != "detached" \
	&& "$3" != "screen" ]] \
	&& echo -e "\nERROR: ${RED}<mode> must be one of \" \", \"detached\" \"screen\"${norm}" \
	&& echo -e "Please run ${0/.\//} with no parameters to get usage\n" \
	&& exit 281

# if $2 = modify $3 must match ^(name|vcpu|memory|disk_type|disk_path|cd_path|os|enable_screen|bind_usb_ports|enable_cloudinit|cloudinit_hostname|cloudinit_userdata)
        [[ "$2" == "modify" ]] \
	&& [[ "$(echo $3|cut -d= -f1)" != "name" \
	&& "$(echo $3|cut -d= -f1)" != "memory" \
        && "$(echo $3|cut -d= -f1)" != "vcpus" \
        && "$(echo $3|cut -d= -f1)" != "disk_type" \
        && "$(echo $3|cut -d= -f1)" != "disk_path" \
        && "$(echo $3|cut -d= -f1)" != "cd_path" \
        && "$(echo $3|cut -d= -f1)" != "os" \
        && "$(echo $3|cut -d= -f1)" != "enable_screen" \
        && "$(echo $3|cut -d= -f1)" != "bind_usb_ports" \
        && "$(echo $3|cut -d= -f1)" != "enable_cloudinit" \
        && "$(echo $3|cut -d= -f1)" != "cloudinit_hostname" \
        && "$(echo $3|cut -d= -f1)" != "cloudinit_userdata" ]] \
        && echo -e "\nERROR: ${RED}<param> must be some of:${norm}${BLUE}
name=|vcpu=|memory=|disk_type=|disk_path=|cd_path=|os=|enable_screen=|bind_usb_ports=|enable_cloudinit=|cloudinit_hostname=|cloudinit_userdata=${norm}\n" |tr "|" "\n"\
	&& echo -e "NOTE: ${RED}minimum parameters to specify on cmdline to modify a VM: ${norm}\n${BLUE}disk_type= \ndisk_path= \nvcpus= \nmemory= \nname= ${norm}\n" \
	&& echo -e "EXAMPLE:\n${BLUE}fbxvm-ctrl 31 modify disk_type=\"qcow2\" disk_path=\"/freeboxdisk/vmdiskpath/myvmdisk.qcow2\" vcpus=\"1\" memory=\"2048\" cd_path=\"/freeboxdisk/vmisopath/debian-11.0.0-arm64-netinst.iso\" os=\"debian\" enable_screen=\"true\" cloudinit_hostname=\"14RV-FSRV-49\" cloudinit_userdata=\"cloudinit-userdata.yml\" bind_usb_ports='\"usb-external-type-c\",\"usb-external-type-a\"' name=\"14RV-FSRV-49.dmz.lan\"${norm}\n" \
	&& echo -e "WARNING: \nWhen modifying VM, if you do not explicitly specify on the cmdline ${PURPL}'cloudinit_userdata=\$val'${norm} (${PURPL}'\$val'${norm} must be a 'yaml cloudinit' ${RED}file${norm}), previous values for ${PURPL}'cloudinit_userdata'${norm} parameter ${RED}will be reset to null ('')${norm}. Others values are retrieve automatically from existing VM configuration\n" \
        && echo -e "Please run ${0/.\//} with no parameters to get usage\n" \
        && exit 282
}


check_ext_tool () {

# check external tool
check_tool curl
check_tool openssl
check_tool websocat

# checking external tools for console : direct / detached / screen 
[[ "${action}" == "console" ]] && check_tool websocat
[[ "${mode}" == "detached" ]] && check_tool dtach
[[ "${mode}" == "screen" ]] && check_tool screen
}


# MAIN 
usage ${vmid} ${action}
testparam ${@} 
check_ext_tool

# call api (global call)
API="vm"
echo -e "\n${white}CONTROL FREEBOX VM${norm}\n"
echo -e "URL CALLED : ${WHITE}${FREEBOX_URL}${_API_BASE_URL}v${_API_VERSION}/${norm}"
echo -e "API CALLED : ${WHITE}$API${norm}"
echo -e "VERB|VM ID : ${WHITE}${vmid}${norm}"
[ ! -z "${action}" ] && echo -e "ACTION : ${WHITE}${action}${norm}"
#answer=$(call_freebox_api "/$API/")
#dump_json_keys_values "$answer" >/dev/null
#debug#dump_json_keys_values "$answer" 
echo -e "RESULT :"


# verb & action

case "${vmid}" in
	list) print_vm_summary && exit 29 ; ;;
	listdisk) list_vm_disk ${@:2} && exit 33 ; ;;
	add) add ${@:2}; ;;
	del) del ${@:2}; ;;
	resize) resize_disk ${@:2}; ;;
esac

case "${action}" in
	start) call_freebox_api "/$API/$vmid/$action" {}; ;;
	restart) call_freebox_api "/$API/$vmid/$action" {}; ;;
	shutdown) call_freebox_api "/$API/$vmid/powerbutton" {}; ;;
	stop) call_freebox_api "/$API/$vmid/$action" {}; ;;
	detail) print_vm_detail ${vmid}; ;;
	modify) modify_vm ${vmid} ${@:2}; ;;
	console) call_freebox-ws_api "/$API/$vmid/$action" ${mode}; ;;
esac

echo


